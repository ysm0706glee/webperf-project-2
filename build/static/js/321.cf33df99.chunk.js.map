{"version":3,"file":"static/js/321.cf33df99.chunk.js","mappings":"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","sources":["../node_modules/framesync/dist/es/on-next-frame.mjs","../node_modules/framesync/dist/es/index.mjs","../node_modules/framesync/dist/es/create-render-step.mjs","../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","../node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs","../node_modules/framer-motion/dist/es/utils/use-constant.mjs","webpack://webperf-project-2/./src/scenes/VideoGame/ui/styles.module.css?93f2","scenes/VideoGame/game/constants.ts","scenes/VideoGame/game/utils.ts","scenes/VideoGame/game/levels.ts","scenes/VideoGame/game/state.ts","scenes/VideoGame/game/actions.ts","scenes/VideoGame/game/entities.ts","scenes/VideoGame/game/gameplay.ts","scenes/VideoGame/VideoGame.tsx","../node_modules/classnames/index.js"],"sourcesContent":["const defaultTimestep = (1 / 60) * 1000;\nconst getCurrentTime = typeof performance !== \"undefined\"\n    ? () => performance.now()\n    : () => Date.now();\nconst onNextFrame = typeof window !== \"undefined\"\n    ? (callback) => window.requestAnimationFrame(callback)\n    : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\nexport { defaultTimestep, onNextFrame };\n","import { onNextFrame, defaultTimestep } from './on-next-frame.mjs';\nimport { createRenderStep } from './create-render-step.mjs';\n\nconst maxElapsed = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nlet isProcessing = false;\nconst frame = {\n    delta: 0,\n    timestamp: 0,\n};\nconst stepsOrder = [\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => (runNextFrame = true));\n    return acc;\n}, {});\nconst sync = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n        if (!runNextFrame)\n            startLoop();\n        return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n}, {});\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = steps[key].cancel;\n    return acc;\n}, {});\nconst flushSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = () => steps[key].process(frame);\n    return acc;\n}, {});\nconst processStep = (stepId) => steps[stepId].process(frame);\nconst processFrame = (timestamp) => {\n    runNextFrame = false;\n    frame.delta = useDefaultElapsed\n        ? defaultTimestep\n        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n    frame.timestamp = timestamp;\n    isProcessing = true;\n    stepsOrder.forEach(processStep);\n    isProcessing = false;\n    if (runNextFrame) {\n        useDefaultElapsed = false;\n        onNextFrame(processFrame);\n    }\n};\nconst startLoop = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!isProcessing)\n        onNextFrame(processFrame);\n};\nconst getFrameData = () => frame;\n\nexport default sync;\nexport { cancelSync, flushSync, getFrameData };\n","function createRenderStep(runNextFrame) {\n    let toRun = [];\n    let toRunNextFrame = [];\n    let numToRun = 0;\n    let isProcessing = false;\n    let flushNextFrame = false;\n    const toKeepAlive = new WeakSet();\n    const step = {\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        cancel: (callback) => {\n            const index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        process: (frameData) => {\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n            toRunNextFrame.length = 0;\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n","import { createContext } from 'react';\n\n/**\n * @public\n */\nvar MotionConfigContext = createContext({\n    transformPagePoint: function (p) { return p; },\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\nexport { MotionConfigContext };\n","import sync, { cancelSync } from 'framesync';\nimport { useContext, useEffect } from 'react';\nimport { useConstant } from './use-constant.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\n\nvar getCurrentTime = typeof performance !== \"undefined\"\n    ? function () { return performance.now(); }\n    : function () { return Date.now(); };\nfunction useAnimationFrame(callback) {\n    var initialTimestamp = useConstant(getCurrentTime);\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    useEffect(function () {\n        if (isStatic)\n            return;\n        var provideTimeSinceStart = function (_a) {\n            var timestamp = _a.timestamp;\n            callback(timestamp - initialTimestamp);\n        };\n        sync.update(provideTimeSinceStart, true);\n        return function () { return cancelSync.update(provideTimeSinceStart); };\n    }, [callback]);\n}\n\nexport { useAnimationFrame };\n","import { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nexport { useConstant };\n","// extracted by mini-css-extract-plugin\nexport default {\"scene\":\"styles_scene__qZ0O2\",\"levelBg\":\"styles_levelBg__14QA8\",\"turret\":\"styles_turret__8k5aR\",\"barrel\":\"styles_barrel__U-NVf\",\"status\":\"styles_status__dhWRL\",\"modal\":\"styles_modal__13+dM\",\"entity\":\"styles_entity__391Vy\",\"entityShot\":\"styles_entityShot__SjEUQ\",\"entityEnemy\":\"styles_entityEnemy__GwT2Q\",\"entityEnemyRed\":\"styles_entityEnemyRed__XIXJK\",\"entityEnemyGreen\":\"styles_entityEnemyGreen__RxbS7\",\"entityEnemyPurple\":\"styles_entityEnemyPurple__6pdrs\",\"entityEnemyBlue\":\"styles_entityEnemyBlue__2W7z4\"};","/**\n * Where does the cannon's barrel start relative to the bottom of the screen.\n */\nexport const barrelOffsetY = -30;\n\n/**\n * How long is the barrel, in pixels.\n */\nexport const barrelLength = 38;\n\n/**\n * How far can you rotate the barrel, in degrees in both directions from pointing straight up.\n */\nexport const barrelMaxDegrees = 80;\n\n/**\n * Try to keep this padding on the sides of the screen.\n */\nexport const scenePadding = 20;\n\n/**\n * How big are the enemies in pixels.\n */\nexport const enemyHeight = 50;\nexport const enemyWidth = 60;\n\n/**\n * How fast do shots move. This is a unit relative to the screen height, per second.\n */\nexport const shotVelocity = 0.8;\n\n/**\n * How many bonus points can you get in the end of a level. This gets multiplied by the accuracy.\n */\nexport const bonusScore = 1000;\n","import { barrelOffsetY, enemyWidth } from \"./constants\";\nimport { Vector } from \"./types\";\n\n/**\n * Get the position of the barrel.\n */\nexport const getBarrelPosition = (): Vector => {\n  return {\n    x: window.innerWidth / 2,\n    y: window.innerHeight + barrelOffsetY,\n  };\n};\n\n/**\n * Create snake lines that either start from the left or the right side of the screen.\n */\nexport const getRandomSnakeLines = (goingLeft: boolean): Vector[] => {\n  let y = 50;\n  let x = goingLeft ? window.innerWidth + enemyWidth : -enemyWidth;\n  const points = [];\n  for (let i = 0; i < 4; i++) {\n    points.push({ x, y });\n    x = goingLeft ? 100 : window.innerWidth - 100;\n    points.push({ x, y });\n    y += window.innerHeight * 0.1;\n    goingLeft = !goingLeft;\n  }\n  y = window.innerHeight + 100;\n  points.push({ x, y });\n\n  return points;\n};\n\n/**\n * Figure out the position of a \"snake\" enemy by tracing its \"age\" across a series of points on the screen.\n */\nexport const getSnakePosition = (\n  lines: Vector[],\n  age: number,\n  speed: number\n): Vector => {\n  let remainingDistance = age * window.innerHeight * speed;\n  let [p1, p2] = lines;\n  let i = 1;\n  for (let i = 1; i < lines.length; i++) {\n    const distance = Math.sqrt(\n      Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)\n    );\n    if (remainingDistance <= distance) {\n      const x = p1.x + (remainingDistance * (p2.x - p1.x)) / distance;\n      const y = p1.y + (remainingDistance * (p2.y - p1.y)) / distance;\n      return { x, y };\n    }\n    remainingDistance -= distance;\n    p1 = p2;\n    p2 = lines[i + 1];\n  }\n  return lines[lines.length - 1];\n};\n","import { enemyHeight, enemyWidth, scenePadding } from \"./constants\";\nimport { EnemySpawn, Vector } from \"./types\";\nimport { getRandomSnakeLines } from \"./utils\";\nimport _ from \"lodash\";\n\n/**\n * Generate a random position for an enemy. Tries to responsively account for enemy widths and padding.\n */\nexport const getRandomSpawnPosition = (enemyWidth: number): Vector => {\n  const padding = scenePadding + enemyWidth / 2;\n  return {\n    x: Math.random() * (window.innerWidth - padding * 2) + padding,\n    y: -enemyHeight,\n  };\n};\n\nconst levelCreators: Array<() => EnemySpawn[]> = [\n  // Level 1\n  () => {\n    return _.times<EnemySpawn>(10, () => ({\n      variant: \"normal\",\n      style: \"Red\",\n      delay: 2,\n      position: getRandomSpawnPosition(enemyWidth),\n      speed: 0.1,\n    }));\n  },\n  // Level 2\n  () => {\n    return _.times<EnemySpawn>(15, (i) =>\n      i % 5\n        ? {\n            variant: \"normal\",\n            style: \"Red\",\n            delay: 1.5,\n            position: getRandomSpawnPosition(enemyWidth),\n            speed: 0.1,\n          }\n        : {\n            variant: \"sine\",\n            style: \"Purple\",\n            delay: 2,\n            position: getRandomSpawnPosition(300),\n            speed: 0.06,\n            sineRadius: 150,\n            sineSpeed: 0.1,\n          }\n    );\n  },\n  // Level 3\n  () => {\n    return [\n      ..._.times<EnemySpawn>(3, () => ({\n        variant: \"normal\",\n        style: \"Red\",\n        delay: 0,\n        position: getRandomSpawnPosition(enemyWidth),\n        speed: 0.1,\n      })),\n      {\n        variant: \"normal\",\n        style: \"Red\",\n        delay: 3,\n        position: getRandomSpawnPosition(enemyWidth),\n        speed: 0.1,\n      },\n      ..._.times<EnemySpawn>(4, () => ({\n        variant: \"normal\",\n        style: \"Red\",\n        delay: 0,\n        position: getRandomSpawnPosition(enemyWidth),\n        speed: 0.1,\n      })),\n      {\n        variant: \"normal\",\n        style: \"Red\",\n        delay: 4,\n        position: getRandomSpawnPosition(enemyWidth),\n        speed: 0.1,\n      },\n      ..._.times<EnemySpawn>(6, () => ({\n        variant: \"normal\",\n        style: \"Red\",\n        delay: 0,\n        position: getRandomSpawnPosition(enemyWidth),\n        speed: 0.1,\n      })),\n    ];\n  },\n  // Level 4\n  () => {\n    return [\n      ..._.times<EnemySpawn>(12, () => ({\n        variant: \"normal\",\n        style: \"Green\",\n        delay: 1.5,\n        position: getRandomSpawnPosition(enemyWidth),\n        speed: 0.18,\n      })),\n    ];\n  },\n  // Level 5\n  () => {\n    return [\n      ..._.times<EnemySpawn>(10, () => ({\n        variant: \"sine\",\n        style: \"Purple\",\n        delay: 2,\n        position: getRandomSpawnPosition(400 + enemyWidth),\n        speed: 0.1,\n        sineRadius: 200,\n        sineSpeed: 0.1,\n      })),\n    ];\n  },\n  // Level 6\n  () => {\n    return [\n      ..._.times<EnemySpawn>(50, () => ({\n        variant: \"snake\",\n        style: \"Blue\",\n        delay: 0.3,\n        position: getRandomSpawnPosition(enemyWidth),\n        lines: getRandomSnakeLines(true),\n        speed: 0.4,\n      })),\n    ];\n  },\n  // Level 7\n  () => {\n    return _.times<EnemySpawn>(50, () => {\n      switch (Math.floor(Math.random() * 4)) {\n        case 0:\n          return {\n            variant: \"sine\",\n            style: \"Purple\",\n            delay: 1 + Math.random() * 1,\n            position: getRandomSpawnPosition(500 + enemyWidth),\n            speed: 0.12,\n            sineRadius: 250,\n            sineSpeed: 0.05 + Math.random() * 0.3,\n          };\n        case 1:\n          return {\n            variant: \"snake\",\n            style: \"Blue\",\n            delay: 0.3 + Math.random() * 1,\n            position: getRandomSpawnPosition(enemyWidth),\n            lines: getRandomSnakeLines(Math.random() > 0.5 ? true : false),\n            speed: 0.4,\n          };\n        default:\n          return {\n            variant: \"normal\",\n            style: \"Green\",\n            delay: 1 + Math.random() * 1,\n            position: getRandomSpawnPosition(enemyWidth),\n            speed: 0.18,\n          };\n      }\n    });\n  },\n];\n\nexport function createLevel(level: number) {\n  if (levelCreators[level - 1]) {\n    return levelCreators[level - 1]();\n  }\n  return [];\n}\n\nexport const levelBackgrounds = [\n  \"hsla(0, 100%, 50%, 0.15)\",\n  \"hsla(40, 100%, 50%, 0.15)\",\n  \"hsla(80, 100%, 50%, 0.15)\",\n  \"hsla(120, 100%, 50%, 0.15)\",\n  \"hsla(200, 100%, 50%, 0.15)\",\n  \"hsla(280, 100%, 50%, 0.15)\",\n  \"hsla(0, 100%, 50%, 0.3)\",\n  \"hsla(0, 100%, 100%, 0.5)\",\n  \"hsla(0, 100%, 50%, 0)\",\n];\n","import { createLevel } from \"./levels\";\nimport { Entity, GameState } from \"./types\";\n\n/**\n * Create the initial game state.\n */\nexport const initialState = (): GameState => {\n  const level = 1;\n  const enemySpawns = createLevel(level);\n  return {\n    entityContainerEl: null,\n    barrelEl: null,\n    statusEl: null,\n    modalEl: null,\n    levelBgEl: null,\n    barrelAngle: 0,\n    entities: [],\n    lastUpdateTime: 0,\n    lives: 3,\n    level,\n    score: 0,\n    shotCount: 0,\n    enemyCount: enemySpawns.length,\n    enemySpawns,\n    lastSpawnTime: 0,\n    modalTime: 0,\n    isGameOver: false,\n  };\n};\n\n/**\n * Reset the game state without nulling elements.\n * Wait 1 second before starting.\n */\nexport const restartGame = (state: GameState) => {\n  const {\n    level,\n    score,\n    enemySpawns,\n    lives,\n    shotCount,\n    enemyCount,\n    isGameOver,\n  } = initialState();\n  Object.assign(state, {\n    level,\n    score,\n    enemySpawns,\n    lives,\n    shotCount,\n    enemyCount,\n    isGameOver,\n    modalTime: 1,\n  });\n};\n\n/**\n * Adds an entity to the game state and UI.\n */\nexport function addEntity(state: GameState, entity: Entity) {\n  if (!state.entityContainerEl) {\n    return;\n  }\n\n  state.entityContainerEl.appendChild(entity.el);\n  state.entities.push(entity);\n}\n\n/**\n * Removes an entities from the scene and marks it for future cleanup.\n * @param entity\n */\nexport function killEntity(entity: Entity) {\n  entity.dead = true;\n  entity.el.remove();\n}\n\n/**\n * Remove all entities from the scene.\n */\nexport function killAllEntities(state: GameState) {\n  state.entities.forEach((entity) => {\n    killEntity(entity);\n  });\n}\n\n/**\n * Clean up all \"dead\" entities from the game state.\n */\nexport function removeDeadEntities(state: GameState) {\n  for (const entity of state.entities) {\n    if (!entity.dead) {\n      [...state.entities, entity];\n    }\n  }\n  // state.entities = state.entities.reduce<Entity[]>(\n  //   (array, item) => (item.dead ? array : [...array, item]),\n  //   []\n  // );\n}\n","import { getBarrelPosition } from \"./utils\";\nimport { barrelMaxDegrees } from \"./constants\";\nimport { createShot } from \"./entities\";\nimport { GameState } from \"./types\";\nimport { addEntity, restartGame } from \"./state\";\n\n/**\n * Update the game state with a new mouse position.\n */\nexport const onMouseMove = (state: GameState, x: number, y: number) => {\n  const barrelPos = getBarrelPosition();\n  const barrelMaxRadians = (barrelMaxDegrees * Math.PI) / 180;\n  state.barrelAngle = Math.min(\n    -Math.PI / 2 + barrelMaxRadians,\n    Math.max(\n      -Math.PI / 2 - barrelMaxRadians,\n      Math.atan2(y - barrelPos.y, x - barrelPos.x)\n    )\n  );\n};\n\n/**\n * Update the game state from a mouse click.\n */\nexport function onMouseClick(state: GameState) {\n  if (state.isGameOver) {\n    restartGame(state);\n    return;\n  }\n  if (state.modalTime > 0) {\n    return;\n  }\n  state.shotCount++;\n  addEntity(state, createShot(state.barrelAngle));\n}\n","import classnames from \"classnames\";\nimport s from \"../ui/styles.module.css\";\nimport { barrelLength, shotVelocity } from \"./constants\";\nimport { getBarrelPosition } from \"./utils\";\nimport { Enemy, EnemySpawn, Entity } from \"./types\";\n\n/**\n * Create an enemy element and metadata.\n */\nexport function createEnemy(enemySpawn: EnemySpawn, spawnTime: number): Entity {\n  const {\n    position: { x, y },\n    style,\n  } = enemySpawn;\n\n  const el = document.createElement(\"div\");\n  el.className = classnames(s.entity, s.entityEnemy, s[`entityEnemy${style}`]);\n  el.style.left = `${x}px`;\n  el.style.top = `${y}px`;\n\n  return {\n    type: \"enemy\",\n    el,\n    spawnTime,\n    enemySpawn,\n  };\n}\n\n/**\n * Create a shot element and metadata.\n */\nexport function createShot(barrelAngle: number): Entity {\n  let { x, y } = getBarrelPosition();\n  x += barrelLength * Math.cos(barrelAngle);\n  y += barrelLength * Math.sin(barrelAngle);\n  const velocity = {\n    x: window.innerHeight * shotVelocity * Math.cos(barrelAngle),\n    y: window.innerHeight * shotVelocity * Math.sin(barrelAngle),\n  };\n  const el = document.createElement(\"div\");\n  el.className = classnames(s.entity, s.entityShot);\n  el.style.left = `${x}px`;\n  el.style.top = `${y}px`;\n\n  return {\n    type: \"shot\",\n    velocity,\n    el,\n  };\n}\n\n/**\n * Calculate score from shooting an enemy.\n */\nexport function scoreFromEnemy(enemy: Enemy) {\n  return 50;\n}\n","import { createEnemy, scoreFromEnemy } from \"./entities\";\nimport {\n  addEntity,\n  killAllEntities,\n  killEntity,\n  removeDeadEntities,\n} from \"./state\";\nimport { Enemy, Entity, GameState } from \"./types\";\nimport { createLevel, levelBackgrounds } from \"./levels\";\nimport { bonusScore } from \"./constants\";\nimport { getSnakePosition } from \"./utils\";\n\n/**\n * The main update function. Runs during each animation frame, runs the whole game play loop\n * and updates entites on screen.\n */\nexport function update(state: GameState, updateTime: number) {\n  // The updateTime is basically how many seconds since the user opened the game URL.\n  // This can be useful for some things. For others it's more useful to have a delta\n  // since the last update.\n  const delta = updateTime - state.lastUpdateTime;\n  state.lastUpdateTime = updateTime;\n\n  // Check if there's a new enemy spawning.\n  checkSpawn(state, updateTime);\n\n  // Update the rotation of the barrel.\n  updateBarrel(state);\n\n  // Move all entities.\n  updateEntities(state, updateTime, delta);\n\n  // Check if there are collisions, either between entities (shots and enemies) or between entities\n  // and the screen boundaries.\n  checkCollisions(state);\n\n  // Update some misc UI elements.\n  updateUI(state, delta);\n}\n\n/**\n * Check if it's time to spawn a new enemy.\n *\n * Each level has a queue of enemySpawns which we spawn in order. Each EnemySpawn can specify its\n * own delay after the previous spawn.\n */\nfunction checkSpawn(state: GameState, updateTime: number) {\n  // Don't spawn anything when modals are open.\n  if (state.modalTime > 0) {\n    return;\n  }\n  const { enemySpawns, lastSpawnTime } = state;\n  const enemySpawn = enemySpawns[0];\n\n  // Is it time yet?\n  if (enemySpawn && updateTime - lastSpawnTime > enemySpawn.delay) {\n    // Yes it is!\n    state.lastSpawnTime = updateTime;\n    enemySpawns.shift();\n\n    addEntity(state, createEnemy(enemySpawn, updateTime));\n  }\n}\n\n/**\n * Update the barrel rotation.\n * @param state\n */\nfunction updateBarrel(state: GameState) {\n  if (state.barrelEl) {\n    state.barrelEl.style.transform = `rotate(${\n      state.barrelAngle + Math.PI / 2\n    }rad)`;\n  }\n}\n\n/**\n * Move each entity according to their movement rules.\n */\nfunction updateEntities(state: GameState, updateTime: number, delta: number) {\n  state.entities.forEach((entity) => {\n    // Shots go in a straight direction based on their velocity.\n    if (entity.type === \"shot\") {\n      const newPos = {\n        x: parseFloat(entity.el.style.left) + entity.velocity.x * delta,\n        y: parseFloat(entity.el.style.top) + entity.velocity.y * delta,\n      };\n      entity.el.style.left = `${newPos.x}px`;\n      entity.el.style.top = `${newPos.y}px`;\n    } else if (entity.type === \"enemy\") {\n      // Enemies move differently based on their variant.\n      const { speed, variant } = entity.enemySpawn;\n\n      // Normal and \"sine\" enemies generally move down according to some speed.\n      if (variant === \"normal\" || variant === \"sine\") {\n        const newY =\n          parseFloat(entity.el.style.top) +\n          window.innerHeight * entity.enemySpawn.speed * delta;\n        entity.el.style.top = `${newY}px`;\n      }\n\n      // Additionally, \"sine\" enemies move in a sine wave pattern.\n      if (variant === \"sine\") {\n        const newX =\n          entity.enemySpawn.position.x +\n          Math.sin(\n            (updateTime * entity.enemySpawn.sineSpeed * window.innerHeight) /\n              100\n          ) *\n            entity.enemySpawn.sineRadius;\n        entity.el.style.left = `${newX}px`;\n      }\n\n      // Finally, \"snake\" enemies move according to predefined lines across the screen.\n      if (variant === \"snake\") {\n        const newPos = getSnakePosition(\n          entity.enemySpawn.lines,\n          updateTime - entity.spawnTime,\n          speed\n        );\n        entity.el.style.left = `${newPos.x}px`;\n        entity.el.style.top = `${newPos.y}px`;\n      }\n    }\n  });\n}\n\n/**\n * Collision detection. How fun!\n */\nfunction checkCollisions(state: GameState) {\n  state.entities.forEach((entityA) => {\n    // Ignore \"dead\" entities ... (we'll clean them up right after).\n    if (entityA.dead) {\n      return;\n    }\n\n    // Check if the entity is colliding with the screen boundaries.\n    const rectA = entityA.el.getBoundingClientRect();\n    const outsideBounds =\n      entityA.type === \"shot\"\n        ? // Shots collide with all boundaries.\n          rectA.top > window.innerHeight ||\n          rectA.bottom < 0 ||\n          rectA.left > window.innerWidth ||\n          rectA.right < 0\n        : // Enemies only collide with bottom of screen.\n          rectA.top > window.innerHeight;\n\n    if (outsideBounds) {\n      if (entityA.type === \"enemy\") {\n        // Oh no!\n        loseLive(state);\n      } else {\n        // Basically a shot hitting the edge... Nothing dramatic.\n        killEntity(entityA);\n      }\n    } else {\n      // Check if the entity is colliding with other entities.\n      state.entities.forEach((entityB) => {\n        if (entityB.dead) {\n          return;\n        }\n        const rectB = entityB.el.getBoundingClientRect();\n\n        // Such simple code, but still capable of causing a migraine. 🙃\n        const hit = !(\n          rectB.left > rectA.right ||\n          rectB.right < rectA.left ||\n          rectB.top > rectA.bottom ||\n          rectB.bottom < rectA.top\n        );\n\n        // Hardcoding entityA=shot and entityB=enemy since we're checking every combination anyways. 😇\n        const shotVsEnemy = entityA.type === \"shot\" && entityB.type === \"enemy\";\n        if (hit && shotVsEnemy) {\n          // Yay!\n          killEntity(entityA);\n          killEntity(entityB);\n          state.score += scoreFromEnemy(entityB);\n\n          checkEndLevel(state);\n        }\n      });\n    }\n  });\n\n  // Filter dead entities.\n  removeDeadEntities(state);\n}\n\n/**\n * Update misc UI elements.\n */\nfunction updateUI(state: GameState, delta: number) {\n  // Update the gameplay status UI.\n  if (state.statusEl) {\n    state.statusEl.innerText = `Level: ${state.level}\\nLives: ${state.lives}\\nScore: ${state.score}`;\n  }\n\n  // Show and hide the modal.\n  if (state.modalEl) {\n    state.modalEl.style.opacity = state.modalTime ? \"1\" : \"0\";\n  }\n\n  // Counting down while a modal is open until the game starts again. Note, the end-game modals have\n  // a modalTime of Number.MAX_VALUE. It's fine! :D\n  if (state.modalTime) {\n    state.modalTime = Math.max(0, state.modalTime - delta);\n  }\n}\n\n/**\n * Oh no, an enemy has hit the bottom of the screen.\n * @param state\n */\nfunction loseLive(state: GameState) {\n  // A life has been lost. :(\n  state.lives--;\n\n  // Maybe even game over?\n  if (state.lives === 0) {\n    state.enemySpawns = [];\n    state.isGameOver = true;\n    showModal(\n      state,\n      `<h1>Game Over!</h1><p>Score: ${state.score}</p><p>Click to play again :)</p>`,\n      Number.MAX_VALUE\n    );\n  } else {\n    showModal(state, `<h1>Whoops!</h1>`, 2);\n\n    // \"reload\" the same level with all of the remaining enemies.\n    const activeEnemies = state.entities\n      .filter((entity) => entity.type === \"enemy\" && !entity.dead)\n      .map((entity) => (entity as Enemy).enemySpawn);\n\n    state.enemySpawns = [...activeEnemies, ...state.enemySpawns];\n  }\n\n  killAllEntities(state);\n}\n\n/**\n * Check if we've reached the end of the level. This function is run immediately after a shot hits an enemy.\n */\nfunction checkEndLevel(state: GameState) {\n  const enemiesRemaining =\n    state.enemySpawns.length ||\n    state.entities.some((entity) => entity.type === \"enemy\" && !entity.dead);\n\n  // Nah, still some enemies to be killed. Keep playing!\n  if (enemiesRemaining) {\n    return;\n  }\n\n  // Calculate some stats for the modal.\n  const accuracy = state.enemyCount / state.shotCount;\n  const accuracyPretty = Math.round(accuracy * 100);\n  const bonus = Math.round(bonusScore * accuracy);\n  showModal(\n    state,\n    `<h1>Level ${state.level} finished!</h1><p>Shot accuracy: ${accuracyPretty}%</p><p>Bonus points: ${bonus}</p>`\n  );\n\n  // Clean up the previous level.\n  killAllEntities(state);\n  state.score += bonus;\n  state.shotCount = 0;\n\n  // Load the next level.\n  state.level++;\n  state.enemySpawns = createLevel(state.level);\n  state.enemyCount = state.enemySpawns.length;\n  if (state.levelBgEl) {\n    state.levelBgEl.style.backgroundColor = levelBackgrounds[state.level];\n  }\n\n  // Or end the game.\n  if (state.enemySpawns.length === 0) {\n    showModal(\n      state,\n      `<h1>Congratulations!</h1><p>You won the game!</p><p>Total score: ${state.score}</p><p>Click to play again :)</p>`,\n      Number.MAX_VALUE\n    );\n    state.isGameOver = true;\n  }\n}\n\n/**\n * Shows a modal. This HTML is put into a modal which fades in and out after `time` seconds.\n */\nfunction showModal(state: GameState, html: string, time = 5) {\n  if (state.modalEl) {\n    state.modalEl.innerHTML = html;\n  }\n  state.modalTime = time;\n}\n","import { useAnimationFrame } from \"framer-motion\";\nimport { useRef, MouseEvent } from \"react\";\nimport s from \"./ui/styles.module.css\";\nimport { initialState } from \"./game/state\";\nimport { onMouseClick, onMouseMove } from \"./game/actions\";\nimport { update } from \"./game/gameplay\";\n\nexport default () => {\n  const gameState = useRef(initialState());\n\n  const mouseMove = (event: MouseEvent) => {\n    onMouseMove(gameState.current, event.clientX, event.clientY);\n  };\n\n  const mouseClick = () => {\n    onMouseClick(gameState.current);\n  };\n\n  useAnimationFrame((time) => {\n    update(gameState.current, time / 1000);\n  });\n\n  return (\n    <div className={s.scene} onMouseMove={mouseMove} onClick={mouseClick}>\n      <div\n        className={s.levelBg}\n        ref={(el) => (gameState.current.levelBgEl = el)}\n      />\n      <div className={s.turret}>\n        <div\n          className={s.barrel}\n          ref={(el) => (gameState.current.barrelEl = el)}\n        />\n      </div>\n      <div ref={(el) => (gameState.current.entityContainerEl = el)} />\n      <div\n        className={s.status}\n        ref={(el) => (gameState.current.statusEl = el)}\n      />\n      <div className={s.modal} ref={(el) => (gameState.current.modalEl = el)}>\n        Game Over\n      </div>\n    </div>\n  );\n};\n","/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n"],"names":["defaultTimestep","getCurrentTime","performance","now","Date","onNextFrame","window","callback","requestAnimationFrame","setTimeout","useDefaultElapsed","runNextFrame","isProcessing","frame","delta","timestamp","stepsOrder","steps","reduce","acc","key","toRun","toRunNextFrame","numToRun","flushNextFrame","toKeepAlive","WeakSet","step","schedule","addToCurrentFrame","buffer","add","indexOf","push","length","cancel","index","splice","delete","process","frameData","i","has","createRenderStep","sync","keepAlive","immediate","startLoop","cancelSync","processStep","stepId","processFrame","Math","max","min","forEach","MotionConfigContext","createContext","transformPagePoint","p","isStatic","reducedMotion","useAnimationFrame","initialTimestamp","init","ref","useRef","current","useConstant","useContext","useEffect","provideTimeSinceStart","_a","update","enemyWidth","getBarrelPosition","x","innerWidth","y","innerHeight","getRandomSnakeLines","goingLeft","points","getRandomSpawnPosition","padding","random","levelCreators","_","variant","style","delay","position","speed","sineRadius","sineSpeed","lines","floor","createLevel","level","levelBackgrounds","initialState","enemySpawns","entityContainerEl","barrelEl","statusEl","modalEl","levelBgEl","barrelAngle","entities","lastUpdateTime","lives","score","shotCount","enemyCount","lastSpawnTime","modalTime","isGameOver","addEntity","state","entity","appendChild","el","killEntity","dead","remove","killAllEntities","onMouseClick","Object","assign","restartGame","cos","sin","velocity","document","createElement","className","classnames","s","left","top","type","createShot","updateTime","enemySpawn","shift","spawnTime","createEnemy","checkSpawn","transform","PI","updateBarrel","newPos","parseFloat","newY","newX","age","remainingDistance","p1","p2","distance","sqrt","pow","getSnakePosition","updateEntities","entityA","rectA","getBoundingClientRect","bottom","right","showModal","Number","MAX_VALUE","activeEnemies","filter","map","loseLive","entityB","rectB","hit","shotVsEnemy","some","accuracy","accuracyPretty","round","bonus","backgroundColor","checkEndLevel","removeDeadEntities","checkCollisions","innerText","opacity","updateUI","html","time","innerHTML","gameState","onMouseMove","event","barrelPos","barrelMaxRadians","atan2","clientX","clientY","onClick","hasOwn","hasOwnProperty","classNames","classes","arguments","arg","argType","Array","isArray","inner","apply","toString","prototype","call","join","module","exports","default"],"sourceRoot":""}